import { Expressions } from "./expressions.js";

const blobs = {};
let worker;

export const HF_BASE = `https://huggingface.co/rhasspy/piper-voices/resolve/v1.0.0/`;

/**
 * Generates phonemes using the Piper Phonemizer.
 *
 * @param {string} piperPhonemizeJsUrl - URL for the Piper phonemize JavaScript file.
 * @param {string} piperPhonemizeWasmUrl - URL for the Piper phonemize WASM file.
 * @param {string} piperPhonemizeDataUrl - URL for the Piper phonemize data file.
 * @param {string} workerUrl - URL for the Web Worker script.
 * @param {string} modelConfigUrl - URL for the model configuration file.
 * @param {string} input - Text input to be processed.
 * @param {function(number): void} onProgress - Callback function to handle progress updates.
 * @param {string = "https://cdnjs.cloudflare.com/ajax/libs/onnxruntime-web/1.17.1/"} onnxruntimeUrl - URL for the ONNX Runtime Web.
 *
 * @returns {Promise<{
 *  phonemes: string[],
 *  phonemeIds: int[],
 * }>}
 */
export const piperPhonemize = (
  piperPhonemizeJsUrl,
  piperPhonemizeWasmUrl,
  piperPhonemizeDataUrl,
  workerUrl,
  modelConfigUrl,
  input,
  onProgress,
  onnxruntimeUrl = "https://cdnjs.cloudflare.com/ajax/libs/onnxruntime-web/1.17.1/"
) => {
  const piperPromise = new Promise((resolve, reject) => {
    worker?.terminate();

    worker = new Worker(workerUrl);
    worker.postMessage({
      kind: "phonemize",
      input,
      speakerId: null,
      blobs,
      piperPhonemizeJsUrl,
      piperPhonemizeWasmUrl,
      piperPhonemizeDataUrl,
      modelUrl: null,
      modelConfigUrl,
      onnxruntimeUrl,
    });
    worker.addEventListener("message", (event) => {
      const data = event.data;
      switch (data.kind) {
        case "output": {
          const phonemes = data.phonemes;
          const phonemeIds = data.phonemeIds;
          resolve({ phonemes, phonemeIds });
          break;
        }
        case "stderr": {
          reject(data.message);
          break;
        }
        case "fetch": {
          if (data.blob) blobs[data.url] = data.blob;
          const progress = data.blob
            ? 1
            : data.total
            ? data.loaded / data.total
            : 0;
          onProgress(Math.round(progress * 100));
          break;
        }
      }
    });
  });
  return piperPromise;
};

/**
 * Generates audio using the Piper model.
 *
 * @param {string} piperPhonemizeJsUrl - URL for the Piper phonemize JavaScript file.
 * @param {string} piperPhonemizeWasmUrl - URL for the Piper phonemize WASM file.
 * @param {string} piperPhonemizeDataUrl - URL for the Piper phonemize data file.
 * @param {string} workerUrl - URL for the Web Worker script.
 * @param {string} modelUrl - URL for the model file.
 * @param {string} modelConfigUrl - URL for the model configuration file.
 * @param {number?} speakerId - ID of the speaker.
 * @param {string} input - Text input to be processed.
 * @param {function(number): void} onProgress - Callback function to handle progress updates.
 * @param {int[]?} phonemeIds - The phonemes to be used for synthesis (as generated by piperPhonemize). Will be generated if not provided.
 * @param {boolean = false} inferEmotion - Whether to infer emotion from the generated audio. Default is false.
 * @param {string = "https://cdnjs.cloudflare.com/ajax/libs/onnxruntime-web/1.17.1/"} onnxruntimeUrl - URL for the ONNX Runtime Web.
 * @param {string = "expression_worker.js"} expressionWorkerUrl - URL for the expression inferrence worker.
 *
 * @returns {Promise<{
 *  file: string,
 *  expressions: Expressions,
 *  duration: number,
 *  input: string,
 *  kind: string,
 *  phonemes: string[],
 *  phonemeIds: int[],
 * }>}
 */
export const piperGenerate = async (
  piperPhonemizeJsUrl,
  piperPhonemizeWasmUrl,
  piperPhonemizeDataUrl,
  workerUrl,
  modelUrl,
  modelConfigUrl,
  speakerId,
  input,
  onProgress,
  phonemeIds,
  inferEmotion = false,
  onnxruntimeUrl = "https://cdnjs.cloudflare.com/ajax/libs/onnxruntime-web/1.17.1/",
  expressionWorkerUrl = "expression_worker.js"
) => {
  let expressionProgress = 0;
  let piperProgress = 0;
  let expressionPromise;
  if (inferEmotion) {
    expressionPromise = Expressions.inferEmotionsFromText(
      input,
      1000,
      expressionWorkerUrl,
      (p) => {
        expressionProgress = p;
        onProgress &&
          onProgress(expressionProgress * 0.5 + piperProgress * 0.5);
      }
    );
  } else {
    expressionPromise = Promise.resolve();
  }
  const piperPromise = new Promise(async (resolve, reject) => {
    if (worker) {
      const alivePromise = new Promise((resolve) => {
        const aliveChecker = (event) => {
          if (event.data.kind === "isAlive") {
            const { isAlive } = event.data;
            if (isAlive) {
              resolve(true);
              worker.removeEventListener("message", aliveChecker);
            } else {
              worker.terminate();
              worker = new Worker(workerUrl);
              resolve(false);
            }
          }
        };
        worker.addEventListener("message", aliveChecker);
      });
      worker.postMessage({
        kind: "isAlive",
        modelUrl,
      });
      const wasAlive = await alivePromise;
    } else {
      worker = new Worker(workerUrl);
    }

    worker.postMessage({
      kind: "init",
      input,
      speakerId,
      blobs,
      piperPhonemizeJsUrl,
      piperPhonemizeWasmUrl,
      piperPhonemizeDataUrl,
      modelUrl,
      modelConfigUrl,
      phonemeIds,
      onnxruntimeUrl,
    });

    worker.addEventListener("message", (event) => {
      const data = event.data;
      switch (data.kind) {
        case "output": {
          const audioBlobUrl = URL.createObjectURL(data.file);
          const rawIpa = data.phonemes.join(" ");
          const ipa = normalizeIpa(rawIpa);
          const duration = data.duration;
          const expressions = new Expressions({ ipa, duration });

          piperProgress = Math.round(100);
          onProgress(
            inferEmotion
              ? piperProgress * 0.5 + expressionProgress * 0.5
              : piperProgress
          );
          resolve({ ...data, file: audioBlobUrl, expressions });
          break;
        }
        case "stderr": {
          console.error(data.message);
          reject(data.message);
          break;
        }
        case "fetch": {
          if (data.blob) blobs[data.url] = data.blob;
          const progress = data.blob
            ? 1
            : data.total
            ? data.loaded / data.total
            : 0;
          piperProgress = Math.round(progress * 100);
          onProgress(
            inferEmotion
              ? piperProgress * 0.5 + expressionProgress * 0.5
              : piperProgress
          );
          break;
        }
      }
    });
  });
  const [expressionData, piperData] = await Promise.all([
    expressionPromise,
    piperPromise,
  ]);

  if (expressionData) {
    expressionData[0].duration = piperData.duration;
  }
  piperData.expressions.faceExpressions = expressionData;
  return piperData;
};

const normalizeIpa = (ipa) => {
  let normedIpa = ipa.replaceAll(" _ ", "");
  if (normedIpa.startsWith("^")) {
    normedIpa = normedIpa.slice(1);
  }
  if (normedIpa.endsWith("$")) {
    normedIpa = normedIpa.slice(0, -1);
  }
  return normedIpa;
};
